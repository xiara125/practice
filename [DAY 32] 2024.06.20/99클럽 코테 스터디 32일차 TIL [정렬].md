> 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë”” 32ì¼ì°¨ TIL [ì •ë ¬]
> 

# ì˜¤ëŠ˜ì˜ ë¬¸ì œ

## [Beginner] 2733. Neither Minimum nor Maximum

Given an integer arrayÂ `nums`Â containingÂ **distinct**Â **positive**Â integers, find and returnÂ **any**Â number from the array that is neither theÂ **minimum**Â nor theÂ **maximum**Â value in the array, orÂ **`-1`**Â if there is no such number.

ReturnÂ *the selected integer.*

**Example 1:**

```
Input: nums = [3,2,1,4]
Output: 2
Explanation: In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.

```

**Example 2:**

```
Input: nums = [1,2]
Output: -1
Explanation: Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.

```

**Example 3:**

```
Input: nums = [2,1,3]
Output: 2
Explanation: Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer.

```

**Constraints:**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`
- All values inÂ `nums`Â are distinct

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [291ms] Beats 84.52%
class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
				    # numsì˜ ê¸¸ì´ê°€ 3ë³´ë‹¤ ì§§ìœ¼ë©´ -1ì„ ë¦¬í„´í•˜ê³ 
				    # ì˜¤ë¥¸ì°¨ìˆœ ì •ë ¬ëœ numsì˜ ê¸¸ì´ê°€ 3ë³´ë‹¤ ê¸¸ë©´ numsì˜ ìì–´ì„œ 2ë²ˆì§¸ ìˆ«ì ë¦¬í„´
            return -1 if len(nums) < 3 else sorted(nums)[1]
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
		    # numsì¤‘ ê°€ì¥ í° ìˆ˜, ê°€ì¥ ì‘ì€ ìˆ˜ ì •ì˜
        minVal, maxVal = min(nums), max(nums)
        
        # numsì˜ ì›ì†Œë¥¼ í•˜ë‚˜ì”© ë¹¼ ì •ì˜í•œ ë‘ ê°œì˜ ë³€ìˆ˜ì™€ ë¹„êµí•œ ë’¤ ê°™ì§€ ì•Šìœ¼ë©´ ê·¸ ìˆ˜ ë¦¬í„´
        for n in nums:
            if n != minVal and n != maxVal:
                return n
        # numsì¤‘ ê°™ì§€ ì•Šì€ê²Œ ì—†ìœ¼ë©´ -1 ë¦¬í„´
        return -1
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
		    # numsì˜ ê¸¸ì´ê°€ 2ë³´ê°€ ì§§ê±°ë‚˜ ê°™ìœ¼ë©´ -1 ë¦¬í„´
        if len(nums) <= 2:
            return -1
        # ì•„ë‹ˆë©´ numsì˜ ë’¤ì—ì„œ 2ë²ˆì§¸ ìˆ«ì ë¦¬í„´
        else:
            return sorted(nums)[-2]
```

## [Middler] 347. Top K Frequent Elements

Given an integer arrayÂ `nums`Â and an integerÂ `k`, returnÂ *the*Â `k`Â *most frequent elements*. You may return the answer inÂ **any order**.

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]

```

**Constraints:**

- `1 <= nums.length <= 105`
- `104 <= nums[i] <= 104`
- `k`Â is in the rangeÂ `[1, the number of unique elements in the array]`.
- It isÂ **guaranteed**Â that the answer isÂ **unique**.

**Follow up:**Â Your algorithm's time complexity must be better thanÂ `O(n log n)`, where n is the array's size.

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [1678ms] Beats 5.02%
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # ì‹œê°„ë³µì¡ë„ O(n log n)
        res = []
        my_list = []

        for n in set(nums):
            my_list.append([nums.count(n), n])

        # ê°œìˆ˜ ë§ì€ ìƒìœ„ kê°œ
        for i in range(k):
            res.append(sorted(my_list, reverse = True)[i][1])
        return res

```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
	def topKFrequent(self, nums: List[int], k: int) -> List[int]:
		# ë”•ì…”ë„ˆë¦¬ ìƒì„±
		frequency = {}

		for num in nums:
			# numsì˜ ìš”ì†Œ numì´ ìƒì„±í•œ ë”•ì…”ë„ˆë¦¬ frequencyì— ì—†ë‹¤ë©´ numí‚¤ì— ê°’ 1ë¡œ ì¶”ê°€
			if num not in frequency:
				frequency[num] = 1
			# ìˆë‹¤ë©´ numí‚¤ì˜ ê°’ +1
			else:
				frequency[num] = frequency[num] + 1
		
		# ê°’ì˜ ê²°ê³¼ë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë¦¬í•˜ê³  ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
		frequency = dict(sorted(frequency.items(), key=lambda x: x[1], reverse=True))
		# ë”•ì…”ë„ˆë¦¬ì˜ keyì˜ ê°’ë§Œì„ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ í›„ kë§Œí¼ ìë¥´ê¸°
		result = list(frequency.keys())[:k]

		return result
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
		    # nums ê° ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” Counter ê°ì²´ ìƒì„±
        freq_table = Counter(nums)
        # ê°œìˆ˜ì˜ ë”°ë¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¨ê´¸ ë¦¬ìŠ¤íŠ¸ ìƒì„±
        ans_table = freq_table.most_common()
        ans = []
        
        # ìƒìœ„ kê°œì˜ ìš”ì†Œë¥¼ ansë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
        for key, _ in ans_table:
            if k <= 0:
                break
            k -= 1
            ans.append(key)
        return ans
```

## [Challenger] 2280. Minimum lines to Represent a Line Chart

You are given a 2D integer arrayÂ `stockPrices`Â whereÂ `stockPrices[i] = [dayi, pricei]`Â indicates the price of the stock on dayÂ `dayi`Â isÂ `pricei`. AÂ **line chart**Â is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:

!https://assets.leetcode.com/uploads/2022/03/30/1920px-pushkin_population_historysvg.png

ReturnÂ *theÂ **minimum number of lines**Â needed to represent the line chart*.

**Example 1:**

!https://assets.leetcode.com/uploads/2022/03/30/ex0.png

```
Input: stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]
Output: 3
Explanation:
The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.
The following 3 lines can be drawn to represent the line chart:
- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).
- Line 2 (in blue) from (4,4) to (5,4).
- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).
It can be shown that it is not possible to represent the line chart using less than 3 lines.

```

**Example 2:**

!https://assets.leetcode.com/uploads/2022/03/30/ex1.png

```
Input: stockPrices = [[3,4],[1,2],[7,8],[2,3]]
Output: 1
Explanation:
As shown in the diagram above, the line chart can be represented with a single line.

```

**Constraints:**

- `1 <= stockPrices.length <= 105`
- `stockPrices[i].length == 2`
- `1 <= dayi, pricei <= 109`
- AllÂ `dayi`Â areÂ **distinct**.

# í’€ì´

## ë‚˜ì˜ í’€ì´ (ì‹¤íŒ¨)

```python
class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        res = 1
        ssp = sorted(stockPrices)

        if len(stockPrices) == 1:
            return 0

        for i in range(1, len(stockPrices)-1):
            a = ssp[i][0]-ssp[i-1][0]
            b = ssp[i][1]-ssp[i-1][1]
            c = ssp[i+1][0]-ssp[i][0]
            d = ssp[i+1][1]-ssp[i][1]
            if ( b/a == d/c):
                pass
            else:
                res += 1
        return res
```

---

# ê²°ë¡ 

## ì˜¤ëŠ˜ì˜ í•™ìŠµ í‚¤ì›Œë“œ

<aside>
ğŸ’¡ ì •ë ¬

</aside>

## ìƒˆë¡­ê²Œ ë°°ìš´ ê²ƒ, ë‹¤ì‹œê¸ˆ ê¹¨ë‹¬ì€ ê²ƒ

1. ìì—°ìˆ˜ë§Œ ê³ ë ¤í•˜ë”ë¼ë„ `n<3`ê³¼ `n=>2`ì˜ íš¨ìœ¨ì€ ë‹¤ë¥´ë‹¤
2. `sorted()`í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ì€ ë¬´ì¡°ê±´ `list`ê°€ ëœë‹¤.
3. `Counter(iterable)` : iterableì˜ ê° ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ ì…ˆ
- íŒŒì´ì¬ì˜ ë‚´ì¥ ëª¨ë“ˆì¸ `collections`ì— í¬í•¨ëœ í´ë˜ìŠ¤
- ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ë°˜í™˜ : í‚¤ê°’ì€ ìš”ì†Œ ê°’ì€ ê·¸ ìš”ì†Œì˜ ë¹ˆë„ ìˆ˜
- ê¸°ë³¸ê°’ ì²˜ë¦¬ : ì—†ëŠ” ìš”ì†Œì˜ ê²½ìš° ê¸°ë³¸ê°’ì„ ì„¤ì •í•´ì£¼ì„œ í‚¤ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•¨(í‚¤ê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ê°’ì´ 0ìœ¼ë¡œ ì²˜ë¦¬)
- ì—°ì‚° ì§€ì› : í•©ì§‘í•©, êµì§‘í•© ë“±ì˜ ì§‘í•©ì—°ì‚° ê°€ëŠ¥
4. `_` : ì–¸ë”ìŠ¤ì½”ì–´(UnderScore)
1. ë¬´ì‹œí•  ë³€ìˆ˜ : íŠ¹ì • ë³€ìˆ˜ë¥¼ ë¬´ì‹œí•  ë•Œ ì‚¬ìš©. ì˜ˆë¥¼ ë“¤ì–´ ë°˜ë³µë¬¸ì´ë‚˜ í•¨ìˆ˜ì—ì„œ íŠ¹ì •ê°’ì„ ë¦¬í„´í•˜ì§€ ì•Šê³ ì í•  ë•Œ ì‚¬ìš©(ì˜¤ëŠ˜ ë¯¸ë“¤ëŸ¬ ë¬¸ì œ ìƒê°í•´ë³¼ë¬¸ì œì—ì„œ ì‚¬ìš©)
2. êµ­ì œì  ì•½ì† : íŠ¹ì • ë³€ìˆ˜ëª…ì„ ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ì§€ì •í•˜ì—¬ ì´ ë³€ìˆ˜ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒì„ ëª…ì‹œì ìœ¼ë¡œ ë‚˜íƒ€ëƒ„

## ì˜¤ëŠ˜ì˜ íšŒê³ 

ì‘ì€ ê²ƒì˜ ì°¨ì´ë¡œ í° ì°¨ì´ê°€ ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ ì‘ì€ ê²ƒì˜ ë””í…Œì¼ì„ ë†“ì¹˜ì§€ ë§ì

ê·¸ë¦¬ê³  ì˜¤ëŠ˜ì€ ë¬¸ì œê°€ ì˜ í’€ë ¤ ë¹„ê¸°ë„ˆ, ë¯¸ë“¤ëŸ¬, ì±Œë¦°ì²˜ ë¬¸ì œê¹Œì§€ ë„ì „í•´ë³´ì•˜ëŠ”ë° ì±Œë¦°ì € ë¬¸ì œ.. ë‚˜ëˆ„ê¸°ë¥¼ ì‚¬ìš©í•˜ë‹ˆ ë¬´í•œì†Œìˆ˜ë¥¼ ê·¼ì‚¬ê°’ìœ¼ë¡œ í‘œí˜„í•˜ê¸°ë•Œë¬¸ì— ì™„ë²½í•œ ë‹µì´ ë‚˜ì˜¤ì§€ ì•Šì•˜ë‹¤. ì¡°ê¸ˆ ë” ê³µë¶€í•´ë³´ê³  ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ë©´ ì¢‹ì„ì§€ ë„ì „í•´ë³´ì!

â€œ#ì •ë ¬ #99í´ëŸ½ #ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ # ê°œë°œì ì·¨ì—… #í•­í•´99 #TIL #LeetCode #2733 #347 #2280â€