> 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë”” 39ì¼ì°¨ TIL [í™]
> 

# ì˜¤ëŠ˜ì˜ ë¬¸ì œ

## [Beginner] 1337. The K Weakest Rows in a Matrix

You are given anÂ `m x n`Â binary matrixÂ `mat`Â ofÂ `1`'s (representing soldiers) andÂ `0`'s (representing civilians). The soldiers are positionedÂ **in front**Â of the civilians. That is, all theÂ `1`'s will appear to theÂ **left**Â of all theÂ `0`'s in each row.

A rowÂ `i`Â isÂ **weaker**Â than a rowÂ `j`Â if one of the following is true:

- The number of soldiers in rowÂ `i`Â is less than the number of soldiers in rowÂ `j`.
- Both rows have the same number of soldiers andÂ `i < j`.

ReturnÂ *the indices of the*Â `k`Â ***weakest**Â rows in the matrix ordered from weakest to strongest*.

**Example 1:**

```
Input: mat =
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]],
k = 3
Output: [2,0,3]
Explanation:
The number of soldiers in each row is:
- Row 0: 2
- Row 1: 4
- Row 2: 1
- Row 3: 2
- Row 4: 5
The rows ordered from weakest to strongest are [2,0,3,1,4].

```

**Example 2:**

```
Input: mat =
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]],
k = 2
Output: [0,2]
Explanation:
The number of soldiers in each row is:
- Row 0: 1
- Row 1: 4
- Row 2: 1
- Row 3: 1
The rows ordered from weakest to strongest are [0,2,3,1].

```

**Constraints:**

- `m == mat.length`
- `n == mat[i].length`
- `2 <= n, m <= 100`
- `1 <= k <= m`
- `matrix[i][j]`Â is either 0 or 1.

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [103ms] Beats 11.46%
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        max_list, res = [], []
        a=0
        for idx,i in enumerate(mat):
            for j in i:

                if 0 not in i:
                    max_list.append([len(i), idx])
                    break
                elif 1 not in i:
                    max_list.append([0, idx])
                    break
                elif j == 1:
                    a+=1
                elif a != 0:
                    max_list.append([a, idx])
                    a = 0
        max_list.sort()

        for i in range(k):
            res.append(max_list[i][1])
        return res
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
	def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
		m = len(mat)
		# mê°œì˜  ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„± 
		# keyë¶€ë¶„ -> ê° ì¸ë±ìŠ¤ 'i'ì— ëŒ€í•´
		# ì²˜ìŒìœ¼ë¡œëŠ” mat[i] : ië²ˆì§¸ í–‰ì˜ ìš”ì†Œë“¤ì˜ ë¦¬ìŠ¤íŠ¸ë¡œ ì •ë ¬í•˜ê³ 
		# ë‘ë²ˆì§¸ë¡œëŠ” i : í–‰ì˜ ì›ë˜ ì¸ë±ìŠ¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
		rows = sorted(range(m), key=lambda i: (mat[i], i))
		# kë¶€í„° ë§¨ ë’¤ê¹Œì§€ ì œê±°
		del rows[k:]
		return rows
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    import heapq
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        lis=[]
        
        for i in range(len(mat)):
            count=0
            for j in range(len(mat[0])):
		            # ìš”ì†Œê°€ 0ì´ë©´ ë°˜ë³µë¬¸ ì¢…ë£Œ
                if(mat[i][j]==0):
                    break
                # 0ì´ ì•„ë‹ˆë©´ count+=1
                else:
                    count+=1
	          # lisë¦¬ìŠ¤íŠ¸ì— [count,i]ë¥¼ í™ìœ¼ë¡œ ì¶”ê°€(ìµœì†Œ í™)
            heapq.heappush(lis,[count,i])
        final=[]
        # kê°€ 0ì¼ ë•Œê¹Œì§€ ë°˜ë³µ
        while(k):
		        # lisì—ì„œ ìµœì†Œê°’ì„ aì— ë„£ìŒ
            a=heapq.heappop(lis)
            final.append(a[1])
            k-=1
        return(final)
```

```python
class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        heap = []
        for row in range(len(mat)):
		        # ê° í–‰ì—ì„œ 1ì˜ ê°œìˆ˜ë¥¼ ì„¸ onesì— ì €ì¥
            ones = mat[row].count(1)
            # heapë¦¬ìŠ¤íŠ¸ì— (ones, row)íŠœí”Œ ì¶”ê°€(í™ì€ onesê¸°ì¤€ìœ¼ë¡œ ì •ë ¬)
            heapq.heappush(heap, (ones, row))
        
        output = []
        while k:
		        # heapì—ì„œ ìµœì†Œ í•©ì˜ ê°’ ê°€ì ¸ì˜¤ê¸° ,_ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê°’
            _, row = heapq.heappop(heap)
            output.append(row)
            k -= 1
        return outputã…‹
```

---

# ê²°ë¡ 

## ì˜¤ëŠ˜ì˜ í•™ìŠµ í‚¤ì›Œë“œ

<aside>
ğŸ’¡ í™(Heap)

</aside>

## ìƒˆë¡­ê²Œ ë°°ìš´ ê²ƒ, ë‹¤ì‹œê¸ˆ ê¹¨ë‹¬ì€ ê²ƒ

1. heapq.heappush(heap, item)ì˜ itemì—ëŠ” (a,b)í˜•íƒœì˜ ê°’ë„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.ë¦¬ìŠ¤íŠ¸ ì•ˆì— [c.d]ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ê²ƒì²˜ëŸ¼

## ì˜¤ëŠ˜ì˜ íšŒê³ 

ì˜¤ëŠ˜ì˜ í‚¤ì›Œë“œ í™ìœ¼ë¡œ í’€ì–´ë³´ë ¤í–ˆìœ¼ë‚˜.. ì•„ì§ ì–´ë–»ê²Œ ì ìš©í•´ì•¼í•˜ëŠ”ì§€ ì˜ ëª¨ë¥´ê² ë‹¤. ë‹¤ë¥¸ ì‚¬ëŒë“¤ì˜ í’€ì´ë¥¼ ë³´ë©´ì„œ ë” ì •ì§„í•´ë³´ë„ë¡ í•˜ì

â€œ#í™ #99í´ëŸ½ #ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ # ê°œë°œì ì·¨ì—… #í•­í•´99 #TIL #LeetCode #1337â€