> 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë”” 31ì¼ì°¨ TIL [ë¬¸ìì—´]
> 

# ì˜¤ëŠ˜ì˜ ë¬¸ì œ

## [Beginner] 2325. Decode the Message

You are given the stringsÂ `key`Â andÂ `message`, which represent a cipher key and a secret message, respectively. The steps to decodeÂ `message`Â are as follows:

1. Use theÂ **first**Â appearance of all 26 lowercase English letters inÂ `key`Â as theÂ **order**Â of the substitution table.
2. Align the substitution table with the regular English alphabet.
3. Each letter inÂ `message`Â is thenÂ **substituted**Â using the table.
4. SpacesÂ `' '`Â are transformed to themselves.
- For example, givenÂ `key = "**hap**p**y** **bo**y"`Â (actual key would haveÂ **at least one**Â instance of each letter in the alphabet), we have the partial substitution table of (`'h' -> 'a'`,Â `'a' -> 'b'`,Â `'p' -> 'c'`,Â `'y' -> 'd'`,Â `'b' -> 'e'`,Â `'o' -> 'f'`).

ReturnÂ *the decoded message*.

**Example 1:**

!https://assets.leetcode.com/uploads/2022/05/08/ex1new4.jpg

```
Input: key = "the quick brown fox jumps over the lazy dog", message = "vkbs bs t suepuv"
Output: "this is a secret"
Explanation: The diagram above shows the substitution table.
It is obtained by taking the first appearance of each letter in "thequickbrownfoxjumps over thelazydog".

```

**Example 2:**

!https://assets.leetcode.com/uploads/2022/05/08/ex2new.jpg

```
Input: key = "eljuxhpwnyrdgtqkviszcfmabo", message = "zwx hnfx lqantp mnoeius ycgk vcnjrdb"
Output: "the five boxing wizards jump quickly"
Explanation: The diagram above shows the substitution table.
It is obtained by taking the first appearance of each letter in "eljuxhpwnyrdgtqkviszcfmabo".
```

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [44ms] Beats 19.80%
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        res = ""
        eng = "abcdefghijklmnopqrstuvwxyz"
        new_key = ''

        for k in key:
            if k == " ":
                pass
            elif k not in new_key:
                new_key += k
        print(new_key)
        my_dict = dict(zip(new_key, eng))

        for m in message:
            if m == " ":
                res += " "
            else:
                res += my_dict[m]
        return res
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        mapping = {' ': ' '}
        i = 0
        res = ''
        letters = 'abcdefghijklmnopqrstuvwxyz'
        
        for char in key:
            if char not in mapping:
                mapping[char] = letters[i]
                i += 1
        
        for char in message:
            res += mapping[char]
                
        return res
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        hashT = {' ': ' '}
        i=97;
        for k in key:
            if k not in hashT and k is not ' ':
                hashT[k] = chr(i)
                i+=1
        return "".join(hashT[m] for m in message)
```

## [Middler] 451. Sort Characters By Frequency

Given a stringÂ `s`, sort it inÂ **decreasing order**Â based on theÂ **frequency**Â of the characters. TheÂ **frequency**Â of a character is the number of times it appears in the string.

ReturnÂ *the sorted string*. If there are multiple answers, returnÂ *any of them*.

**Example 1:**

```
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.

```

**Example 2:**

```
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.

```

**Example 3:**

```
Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.

```

**Constraints:**

- `1 <= s.length <= 5 * 105`
- `s`Â consists of uppercase and lowercase English letters and digits.

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [60ms] Beats 20.22%
class Solution:
    def frequencySort(self, s: str) -> str:
        res = ""
        my_dict = {}
        string = set(s)

        for i in string:
            my_dict[i] = s.count(i)

        my_dict = sorted(my_dict.items(), key= lambda item:item[1], reverse=True)

        for k,v in my_dict:
            res += (k*v)

        return res
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        counter = Counter(s)
        pq = [(-freq, char) for char, freq in counter.items()]
        heapq.heapify(pq)
        result = ''
        while pq:
            freq, char = heapq.heappop(pq)
            result += char * -freq
        return result
```

## ìƒê°í•´ë³¼ í’€ì´

```python
def frequencySort(self, s: str) -> str:
	sCounter = Counter(s)
	result = []
	for key, value in sorted(sCounter.items(), key=lambda x:x[1], reverse=True):
		result.append(key*value)
	return ''.join(result)
```

---

# ê²°ë¡ 

## ì˜¤ëŠ˜ì˜ í•™ìŠµ í‚¤ì›Œë“œ

<aside>
ğŸ’¡ ë¬¸ìì—´

</aside>

## ìƒˆë¡­ê²Œ ë°°ìš´ ê²ƒ, ë‹¤ì‹œê¸ˆ ê¹¨ë‹¬ì€ ê²ƒ

1. ë”•ì…”ë„ˆë¦¬.items() : ë”•ì…”ë„ˆë¦¬ì˜ í‚¤-ê°’ ìŒì„ ë‚˜íƒ€ë‚´ëŠ” íŠœí”Œë“¤ì„ ë°˜í™˜í•˜ëŠ” ë§¤ì„œë“œ
2. sorted(iterable, key=None,  rebersw = False) : iterableê°ì²´ë¥¼ ì •ë ¬í•˜ì—¬ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
- key = None : ì •ë ¬ ê¸°ì¤€ì„ ë‚˜íƒ€ë‚´ëŠ” í•¨ìˆ˜.
  ê¸°ë³¸ê°’ None
    â†’ key=lambda item:item[1] 
         lambdaí•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ë”•ì…”ë„ˆë¦¬ì˜ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ë„ë¡ ì§€ì •
- reverse = False : ì˜¤ë¦„ì°¨ìˆœ, ë‚´ë¦¼ì°¨ìˆœ ì§€ì •
  ê¸°ë³¸ê°’ False(ì˜¤ë¦„ì°¨ìˆœ - 0,1,2)
3. lambda arguments: expression : ìµë³€í•¨ìˆ˜ë¡œ í•œ ì¤„ë¡œ ê°„ê²°í•˜ê²Œ í•¨ìˆ˜ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆëŠ” íŒŒì´ì¬ì˜ ê¸°ëŠ¥
- lambda : ëŒë‹¤ í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” í‚¤ì›Œë“œ
- arguments : í•¨ìˆ˜ì˜ ì¸ìë“¤ì„ ë‚˜íƒ€ëƒ„. ì¸ìê°€ ì—¬ë˜ê°œë©´ ì½¤ë§ˆ(,)ë¡œ êµ¬ë¶„ë¨
- expression : í•¨ìˆ˜ì˜ ì‹ì„ ë‚˜íƒ€ëƒ„. í•¨ìˆ˜ê°€ ë°˜í™˜í•  ê²°ê³¼ë¥¼ ê³„ì‚°í•˜ëŠ” ë¶€ë¶„

< íŠ¹ì§• >
1. ìµëª…í•¨ìˆ˜ : ëŒë‹¤í•¨ìˆ˜ëŠ” ì´ë¦„ì´ ì—†ëŠ” ìµëª…í•¨ìˆ˜ë¡œ ì •ì˜ 
    ì´ í•¨ìˆ˜ë¥¼ ë³€ìˆ˜ì— í• ë‹¹í•˜ê±°ë‚˜ ë‹¤ë¥¸ í•¨ã……ì˜ ì¸ìë¡œ ì „ë‹¬í•  ìˆ˜ ìˆìŒ
2. ê°„ê²°ì„¤ : í•œ ì¤„ë¡œ ê°„ê²°í•˜ê²Œ í‘œí˜„ ê°€ëŠ¥.
3. ì¦‰ì‹œ ì‹¤í–‰ : ì •ì˜ì™€ ë™ì‹œì— ì¦‰ì‹œ ì‚¬ìš©ë¨. ë”°ë¼ì„œ ì¬ì‚¬ìš©í•  í•„ìš”ê°€ ì—†ì„ ë•Œ ìœ ìš©
4. ì œí•œì ì¸ ê¸°ëŠ¥ : ë‹¨ì¼ í‘œí˜„ì‹ë§Œì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë³µì¡í•œ í•¨ìˆ˜ë‚˜ ì—¬ëŸ¬ ì¤„ì˜ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ì—†ìŒ
(ë‹¨ì¼í‘œí˜„ì‹ í•˜ë‚˜ì˜ ê²°ê³¼ê°’ì„ ê³„ì‚°í•˜ëŠ”ë° í•„ìš”í•œ ìµœì†Œí•œì˜ ì½”ë“œ ë¸”ë¡. ë³´í†µ í•œ ì¤„ë¡œ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ì½”ë“œë¥¼ ëœ»í•¨)

< ì‚¬ìš© ë°©ë²•ë“¤ >
1. í•¨ìˆ˜ì˜ ì¸ìë¡œ ì „ë‹¬ : ë‹¤ë¥¸ í•¨ìˆ˜ì˜ ì¸ìë¡œ ëŒë‹¤ í•¨ìˆ˜ë¥¼ ì „ë‹¬í•˜ì—¬ ê°„ë‹¨í•œ ê¸°ëŠ¥ì„ ì¦‰ì„ì—ì„œ ì •ì˜í•  ìˆ˜ ìˆìŒ
2. ë¦¬ìŠ¤íŠ¸ ì •ë ¬ : sorted()í•¨ìˆ˜ì˜ keyì¸ìë¡œ ì‚¬ìš©í•˜ì—¬ ì •ë ¬ ê¸°ì¤€ì„ ì§€ì •í•  ìˆ˜ ìˆìŒ
3. ì•± í•©ìˆ˜ : map()í•¨ìˆ˜ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ ê° ìš”ì†Œì— ëŒ€í•´ íŠ¹ì • ì—°ì‚°ì„ ì ìš©í•  ìˆ˜ ìˆìŒ

## ì˜¤ëŠ˜ì˜ íšŒê³ 

ìµœê·¼ ì¶”ì²œìˆ˜ê°€ ë†’ì€ í’€ì´ë“¤ê³¼ ë¹„êµí•˜ë©´ íš¨ìœ¨ì„ ì ì§€ë§Œ ì‹œì‘ì ,ì ‘ê·¼ ë°©ë²•ì´ ë¹„ìŠ¤í•´ì§€ëŠ” ê²ƒì„ ë³´ë©°, ì¡°ê¸ˆì€ ë‚˜ë„ ìµìˆ™í•´ì¡Œë‚˜ í•˜ëŠ” ìƒê°ì´ ë“ ë‹¤. ì„±ì¥í•˜ëŠ” ê²ƒì´ ë³´ì´ë©´ ê·¸ê²ƒì´ ë™ë ¥ì´ ë˜ê³¤í•˜ëŠ”ë° ë” ì—´ì‹¬íˆ í•´ë³´ì!

â€œ#ë¬¸ìì—´ #99í´ëŸ½ #ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ # ê°œë°œì ì·¨ì—… #í•­í•´99 #TIL #LeetCode #2325 #451â€