> 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë”” 38ì¼ì°¨ TIL [í™]
> 

# ì˜¤ëŠ˜ì˜ ë¬¸ì œ

## [Beginner] 2500. Delete Greatest Value inEach Row

You are given anÂ `m x n`Â matrixÂ `grid`Â consisting of positive integers.

Perform the following operation untilÂ `grid`Â becomes empty:

- Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.
- Add the maximum of deleted elements to the answer.

**Note**Â that the number of columns decreases by one after each operation.

ReturnÂ *the answer after performing the operations described above*.

**Example 1:**

!https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg

```
Input: grid = [[1,2,4],[3,3,1]]
Output: 8
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.
- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.
- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.
The final answer = 4 + 3 + 1 = 8.

```

**Example 2:**

!https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg

```
Input: grid = [[10]]
Output: 10
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 10 from the first row. We add 10 to the answer.
The final answer = 10.

```

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `1 <= grid[i][j] <= 100`

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [88ms] Beats 63.34%
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:

        for i in range(len(grid)):
            grid[i].sort()

        grid = list(zip(*grid))

        max_values = []
        for row in grid:
            max_value = max(row)
            max_values.append(max_value)

        return sum(max_values)
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for row in grid:
            heapify(row)

        return sum(max(heappop(row) for row in grid) for _ in range(len(grid[0])))
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for row in grid:
            heapq.heapify(row)

        res = 0
        while grid[0]:
            tmp = []
            for row in grid:
                tmp.append(heapq.heappop(row))
            res += max(tmp)

        return res
```

---

# ê²°ë¡ 

## ì˜¤ëŠ˜ì˜ í•™ìŠµ í‚¤ì›Œë“œ

<aside>
ğŸ’¡ í™(Heap)

</aside>

## ìƒˆë¡­ê²Œ ë°°ìš´ ê²ƒ, ë‹¤ì‹œê¸ˆ ê¹¨ë‹¬ì€ ê²ƒ

### < í™ >

1. í™(Heap) : ìë£Œêµ¬ì¡° ì¤‘ í•˜ë‚˜ë¡œ, ì£¼ë¡œ ìš°ì„ ìˆœìœ„ í(priority queue)ë¥¼ êµ¬í˜„í•˜ëŠ” ë° ì‚¬ìš©
    1. ìµœëŒ€ í™(Max Heap)
        1. ë¶€ëª¨ ë…¸ë“œì˜ ê°’ì´ í•­ìƒ ìì‹ ë…¸ë“œì˜ ê°’ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ì™„ì „ ì´ì§„íŠ¸ë¦¬(ë§ˆì§€ë§‰ ë ˆë²¨ì„ ì œì™¸í•œ ëª¨ë“  ë ˆë²¨ì´ ë…¸ë“œë¡œ ê½‰ ì±„ì›Œì ¸ ìˆìœ¼ë©°, ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ë…¸ë“œë“¤ì€ ì™¼ìª½ë¶€í„° ì±„ì›Œì§€ëŠ” êµ¬ì¡°)
        2. ë”°ë¼ì„œ íŠ¸ë¦¬ì˜ ìµœìƒë‹¨ ë£¨íŠ¸ì— ìˆëŠ” ê°’ì´ ìµœëŒ€ ê°’
        3.  ìµœëŒ€ í™ì—ì„œëŠ” ë£¨íŠ¸ì— ìˆëŠ” ê°’ì´ í•­ìƒ í¬ë©°, ê° ë…¸ë“œì˜ ê°’ì€ ê·¸ ìì‹ ë…¸ë“œë“¤ì˜ ê°’ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìŒ.
    2. ìµœì†Œ í™(Min Heap)
        1. ë¶€ëª¨ ë…¸ë“œì˜ ê°’ì´ í•­ìƒ ìì‹ ë…¸ë“œì˜ ê°’ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì™„ì „ ì´ì§„íŠ¸ë¦¬
        2. ë”°ë¼ì„œ íŠ¸ë¦¬ì˜ ìµœìƒë‹¨ ë£¨íŠ¸ì— ìˆëŠ” ê°’ì´ ìµœì†Œê°’
        3. ìµœì†Œ í™ì—ì„œëŠ” ë£¨ë“œì— ìˆëŠ” ê°’ì´ í•­ìƒ ì‘ìœ¼ë©°, ê° ë…¸ë“œì˜ ê°’ì€ ê·¸ ìì‹ ë…¸ë“œë“¤ì˜ ê°’ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìŒ
2. í™ì˜ ì£¼ìš” ì—°ì‚°
    1. ì‚½ì…
        1. ì¼ë°˜ì ìœ¼ë¡œ ìƒˆë¡œìš´ ìš”ì†ŒëŠ” í™ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ì¶”ê°€
        2. ì¶”ê°€ëœ ìš”ì†Œë¥¼ ì ì ˆí•œ ìœ„ì¹˜ë¡œ ì¬ë°°ì¹˜í•˜ì—¬ í™ì˜ íŠ¹ì„±ì„ ìœ ì§€(ìµœëŒ€ í™, ìµœì†Œ í™)
    2. ì‚­ì œ
        1. ì¼ë°˜ì ìœ¼ë¡œ í™ì—ì„œëŠ” ë£¨íŠ¸ ë…¸ë“œë¥¼ ì‚­ì œ
        2. ì‚­ì œëœ ë£¨íŠ¸ ë…¸ë“œëŠ” ë³´í†µ í™ì˜ ë§ˆì§€ë§‰ ë…¸ë“œë¡œ ì´ë™ì‹œí‚¨ í›„ ì ì ˆí•œ ìœ„ì¹˜ë¡œ ì¬ë°°ì¹˜í•˜ì—¬ í™ì˜ íŠ¹ì„± ìœ ì§€
        3. ìµœëŒ€ í™ì—ì„œëŠ” ë£¨íŠ¸ë¥¼ ì‚­ì œí•˜ë©´ íŠ¸ë¦¬ì—ì„œ ê°€ì¥ í° ìš”ì†Œê°€ ì œê±°ë¨
        4. ìµœì†Œ í™ì—ì„œëŠ” ë£¨íŠ¸ë¥¼ ì‚­ì œí•˜ë©´ íŠ¸ë¦¬ì—ì„œ ê°€ì¥ ì‘ì€ ìš”ì†Œê°€ ì œê±°ë¨
    3. í™ êµ¬ì„±
        1. ì£¼ì–´ì§„ ë°°ì—´ì„ í™ êµ¬ì¡°ë¡œ ë³€í™˜í•˜ëŠ” ì—°ì‚°
        2. ì£¼ì–´ì§„ ë°°ì—´ì˜ ê° ìš”ì†Œë¥¼ ìˆœì„œëŒ€ë¡œ í™ì— ì‚½ì…í•˜ëŠ” ë°©ë²•ì´ ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë¨
3. í™ì˜ ë§¤ì„œë“œ
    1. íŒŒì´ì¬ì˜ heapq : ìµœì†Œ í™ ì§€ì›, ìµœëŒ€ í™ êµ¬í˜„ì„ ìœ„í•´ì„œëŠ” ìš”ì†Œì˜ ë¶€í˜¸ë¥¼ ë°˜ì „ì‹œí‚¤ë©´ ë¨
    2. heapq.heapify(heap)
        - ì£¼ì–´ì§„ ë¦¬ìŠ¤íŠ¸ë‚˜ ë°°ì—´ì„ í™ íŠ¹ì„±ì„ ë§Œì¡±í•˜ë„ë¡ ì¬ë°°ì—´
        - ì‹œê°„ ë³µì¡ë„ : O(n)
    3. heapq.heappush(heap, item)
        - í™ì— ìƒˆë¡œìš´ ìš”ì†Œë¥¼ ì¶”ê°€
        - ìƒˆë¡œìš´ ìš”ì†ŒëŠ” í™ì˜ ë§ˆì§€ë§‰ì— ì¶”ê°€ë˜ê³  í™ ì†ì„±ì„ ë§Œì¡±í•˜ë„ë¡ ìë™ìœ¼ë¡œ ì¡°ì •
        - ì‹œê°„ ë³µì¡ë„ : O(log n )
    4. heapq.heappop(heap)
        - í™ì—ì„œ ê°€ì¥ ì‘ì€(ë˜ëŠ” ê°€ì¥ í°) ìš”ì†Œë¥¼ ì‚­ì œí•˜ê³  ë°˜í™˜.
        - ì‚­ì œ í›„ì—ëŠ” í™ ì†ì„±ì„ ìœ ì§€í•˜ë„ë¡ ìë™ìœ¼ë¡œ ì¡°ì •
        - ì‹œê°„ ë³µì¡ë„ : O(log n)
    5. heapq.heapreplace(heap, item)
        - í™ì—ì„œ ê°€ì¥ ì‘ì€(ë˜ëŠ” ê°€ì¥ í°)ìš”ì†Œë¥¼ ì‚­ì œí•˜ê³  ìƒˆë¡œìš´ ìš”ì†Œë¥¼ ì¶”ê°€
        - heappop()ê³¼ heappush()ë¥¼ í•œ ë²ˆì— ìˆ˜í–‰í•˜ëŠ” íš¨ê³¼ê°€ ìˆìœ¼ë©° ì´í›„ í™ ì†ì„±ì„ ìœ ì§€í•˜ë„ë¡ ìë™ìœ¼ë¡œ ì¡°ì •
        - ì‹œê°„ ë³µì¡ë„ : O(log n)
    6. heapq.nlarget(n, iterable, key=None) / heapq.nsmallest(n, iterable, key=None)
        - iterableì—ì„œ ê°€ì¥ í° nê°œ / ê°€ì¥ ì‘ì€ nê°œì˜ ìš”ì†Œë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜
        - keyì¸ìë¥¼ í†µí•´ ë¹„êµ í•¨ìˆ˜ë¥¼ ì§€ì •
        - ì‹œê°„ ë³µì¡ë„ : O(n log k) â†’ n:iterableì˜ ê¸¸ì´, k:ë°˜í™˜í•  ìš”ì†Œì˜ ê°œìˆ˜

## ì˜¤ëŠ˜ì˜ íšŒê³ 

í™â€¦ë„ ë§ì´ ê³µë¶€í•´ì•¼ê² ë‹¤. ì‰¬ìš´ ê²ƒë§Œ ë‚´ê°€ ì˜ í•  ìˆ˜ ìˆëŠ” ê²ƒë§Œ í•  ìˆ˜ëŠ” ì—†ìœ¼ë‹ˆê¹Œ

í™ë„ ìŠ¤íƒë„ íë„â€¦ì•ìœ¼ë¡œë„ ì—´ì‹¬íˆ í•´ë³´ì!

â€œ#í™ #Heap #99í´ëŸ½ #ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ # ê°œë°œì ì·¨ì—… #í•­í•´99 #TIL #LeetCode #2500â€