> 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë”” 30ì¼ì°¨ TIL [ë¬¸ìì—´]
> 

# ì˜¤ëŠ˜ì˜ ë¬¸ì œ

## [Beginner] 1528. Shuffle String

You are given a stringÂ `s`Â and an integer arrayÂ `indices`Â of theÂ **same length**. The stringÂ `s`Â will be shuffled such that the character at theÂ `ith`Â position moves toÂ `indices[i]`Â in the shuffled string.

ReturnÂ *the shuffled string*.

**Example 1:**

!https://assets.leetcode.com/uploads/2020/07/09/q1.jpg

```
Input: s = "codeleet",indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.

```

**Example 2:**

```
Input: s = "abc",indices = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.

```

**Constraints:**

- `s.length == indices.length == n`
- `1 <= n <= 100`
- `s`Â consists of only lowercase English letters.
- `0 <= indices[i] < n`
- All values ofÂ `indices`Â areÂ **unique**.

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [60ms] Beats 18.75%
class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = ''
        my_list = list(zip(indices, s))
        for a, b in sorted(my_list):
            res += b
        return res
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for index, char in enumerate(s):
		        # indices ë¦¬ìŠ¤íŠ¸ì— ì €ì¥ëœ ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ëŠ” ìœ„ì¹˜ì— ë¬¸ì charì„ ë„£ìŒ
            res[indices[index]] = char
        return "".join(res)
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:

        return ''.join([j for (i,j) in sorted(zip(indices,s))])
```

## [Middler] 1529. Minimum Suffix Flips

You are given aÂ **0-indexed**Â binary stringÂ `target`Â of lengthÂ `n`. You have another binary stringÂ `s`Â of lengthÂ `n`Â that is initially set to all zeros. You want to makeÂ `s`Â equal toÂ `target`.

In one operation, you can pick an indexÂ `i`Â whereÂ `0 <= i < n`Â and flip all bits in theÂ **inclusive**Â rangeÂ `[i, n - 1]`. Flip means changingÂ `'0'`Â toÂ `'1'`Â andÂ `'1'`Â toÂ `'0'`.

ReturnÂ *the minimum number of operations needed to make*Â `s`*equal to*Â `target`.

**Example 1:**

```
Input: target = "10111"
Output: 3
Explanation: Initially, s = "00000".
Choose index i = 2: "00000" -> "00111"
Choose index i = 0: "00111" -> "11000"
Choose index i = 1: "11000" -> "10111"
We need at least 3 flip operations to form target.

```

**Example 2:**

```
Input: target = "101"
Output: 3
Explanation: Initially, s = "000".
Choose index i = 0: "000" -> "111"
Choose index i = 1: "111" -> "100"
Choose index i = 2: "100" -> "101"
We need at least 3 flip operations to form target.

```

**Example 3:**

```
Input: target = "00000"
Output: 0
Explanation: We do not need any operations since the initial s already equals target.

```

**Constraints:**

- `n == target.length`
- `1 <= n <= 105`
- `target[i]`Â is eitherÂ `'0'`Â orÂ `'1'`.

# í’€ì´

## ë‚˜ì˜ í’€ì´

```python
# [62ms] Beats 41.73%
class Solution:
    def minFlips(self, target: str) -> int:
        res = 1

        if target[0] == "0":
            res -= 1

        for i in range(1, len(target)):
            if target[i] != target[i-1]:
                res += 1

        return res
```

## ì¶”ì²œìˆ˜ê°€ ê°€ì¥ ë§ì€ í’€ì´

```python
class Solution:
    def minFlips(self, target: str) -> int:
		    # 0ì´ ë§¨ ì•ì— ì˜¤ì§€ ì•Šì„ ë•Œë¥¼ ëŒ€ë¹„í•˜ì—¬ "0"ì¶”ê°€
        return len(list(groupby("0" + target)))-1
```

## ìƒê°í•´ë³¼ í’€ì´

```python
class Solution:
    def minFlips(self, target: str) -> int:
        flips = 0
        prev = '0'
        for char in target:
            if char != prev:
                flips += 1
            prev = char
        
        return flips
```

---

# ê²°ë¡ 

## ì˜¤ëŠ˜ì˜ í•™ìŠµ í‚¤ì›Œë“œ

<aside>
ğŸ’¡ ë¬¸ìì—´

</aside>

## ìƒˆë¡­ê²Œ ë°°ìš´ ê²ƒ, ë‹¤ì‹œê¸ˆ ê¹¨ë‹¬ì€ ê²ƒ

1. `groupby(iterable, key=None)` : iterableì˜ ì—°ì†ì ì¸ ë™ì¼í•œ ìš”ì†Œë“¤ì„ ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì–´ì¤Œ
- itertoolsëª¨ë“ˆì— í¬í•¨ëœ í•¨ìˆ˜
- `iterable` : ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì„ ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ê°ì²´(ë¦¬ìŠ¤íŠ¸, íŠœí”Œ, ë¬¸ìì—´ ë“±)
- `key` : ê·¸ë£¹ì„ ë‚˜ëˆ„ëŠ” ê¸°ì¤€ì´ ë˜ëŠ” í•¨ìˆ˜ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŒ
    ê¸°ë³¸ê°’ = None ì´ë©° ì´ ê²½ìš° ì—°ì†ëœ ë™ì¼í•œ ê°’ë“¤ì„ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë£¹í™”í•¨

## ì˜¤ëŠ˜ì˜ íšŒê³ 

ì „ì— ìƒˆë¡­ê²Œ ì•Œì•˜ë˜ ê²ƒë„ ë‹¤ì‹œ ì ê³ , ì ë‹¤ë³´ë©´ ì“°ê²Œë  ë‚ ì´ ì˜¨ë‹¤! ì˜¤ëŠ˜ì˜ zipí•¨ìˆ˜ ì²˜ëŸ¼! ì´ë ‡ê²Œ ì“°ëŠ” ë•Œê°€ ë§ì•„ì§€ë‹¤ë³´ë©´ ì¢€ ë” ìµìˆ™í•´ì§€ê³  ì™„ë²½í•˜ê²Œ ë‹¤ë£° ìˆ˜ ìˆê² ì§€!!

â€œ#ë¬¸ìì—´ #99í´ëŸ½ #ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ # ê°œë°œì ì·¨ì—… #í•­í•´99 #TIL #LeetCode #1528â€